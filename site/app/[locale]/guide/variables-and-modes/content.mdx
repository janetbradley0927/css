## Overview [sr-only]

This document explains how to define and use variables and modes in the Master CSS framework. Variables allow for reusable values throughout your styles, while modes enable conditional styling for different contexts like light/dark themes.

---

## Understanding variables
Variables in Master CSS provide a way to define reusable values that can be referenced throughout your styling. They help maintain consistency and make theme changes simpler.

### Defining variables
Variables are defined in the [`variables`](/guide/configuration#variables) section of your configuration file. The basic syntax follows a hierarchical structure:
```ts name=master.css.js
export default {
    variables: {
        primary: '#000',    /* primary */
        full: '100%',       /* full */
        md: 20              /* md */
    }
}
```
- Variable `primary` is parsed as a color-type variable.
- Variable `full` is parsed as a string-type variable.
- Variable `md` is parsed as a number-type variable.

### Using variables in classes
Once defined, you can use these variables in your markup. The syntax for using variables is straightforward:
```html
<div class="bg:primary">...</div>
<div class="w:full">...</div>
<div class="m:md">...</div>
```
(i) Spacing variables are recommended to be defined in [`spacing`](/guide/variables#add-a-spacing-variable) section of your configuration file.

### Contextual resolution of variables
Master CSS resolves variable names like `primary` based on their usage context. When used with color-related properties — such as `background-color` or its shorthand `bg` — the system maps `primary` accordingly:
```html
<div class="background-color:primary">…</div>
<div class="bg:primary">…</div><!-- [!code highlight] -->
```
This contextual alias resolution avoids conflicts with similarly named variables and ensures consistent, predictable behavior. For example, `variables.primary` always maps to a color property when used in a color context, never to unrelated properties. This design promotes concise, semantic markup without sacrificing clarity.

### Namespace-aware variable mapping
Variables can be defined within the namespace of a specific CSS property and applied using shorthand syntax. For example, you can define a custom `font-family` variable in your configuration:
```js name=master.css.js
/** @type {import('@master/css').Config} */
export default {
    variables: {
        'font-family': {
            'open-sans': 'Open Sans' /* [!code highlight] */
        }
    }
}
```
Once defined, you can reference the variable in your markup using the shorthand property:
```html
<div class="font-family:open-sans">...</div>
<div class="font:open-sans">...</div><!-- [!code highlight] -->
```

This ensures that `open-sans` is only interpreted as a `font-family` value, promoting both clarity and brevity in your code.

---

## Modes for variables
Modes in Master CSS allow you to define different variable values based on the context, such as light or dark themes. This enables you to create responsive designs that adapt to user preferences or system settings.

### Mode triggers
Master CSS supports several mode triggers, allowing you to choose how modes are applied in your styles. The available triggers are:

- `media`: Uses media queries to apply the mode based on user preferences (e.g., light/dark mode).
- `class`: Applies the mode based on a class name.
- `host`: Applies the mode based on the shadow host element's class.

For example, apply the background color `#000` in dark mode:
```html
<div class="bg:black@dark">
```
Drive theme styles through media queries
```js name=master.css.js
export default {
    modeTrigger: 'media' /* default */ /* [!code highlight] */
}
```
<details>
    <summary>Generated CSS</summary>
    ```css
    @media (prefers-color-scheme: dark) { .bg\:#000000 { background-color: #000000 } }
    ```
</details>
Drive theme styles through CSS classes
```js name=master.css.js
export default {
    modeTrigger: 'class' /* [!code highlight] */
}
```
<details>
    <summary>Generated CSS</summary>
    ```css
    .dark .bg\:#000000 { background-color: #000000 }
    ```
</details>
Drive theme styles through shadow DOM's host
```js name=master.css.js
export default {
    modeTrigger: 'host' /* [!code highlight] */
}
```
<details>
    <summary>Generated CSS</summary>
    ```css
    :host(.dark) .bg\:#000000 { background-color: #000000 }
    ```
</details>

---

## Using modes in classes
Modes can be applied to individual classes using the `@<mode>` syntax:
```html
<div class="bg:black@dark">...</div>
<div class="bg:white@light">...</div>
```
This allows you to specify different styles for different modes without needing to define variables or components for each mode.

---

## Variable inlining mechanism
For non-mode variables, optimization is achieved by directly inlining values `#000` and removing intermediate references `variables.primary`.
```css
.bg\:primary {
    background-color: #000;
}
```
You can also use native CSS variable declarations explicitly, but it will not generate `--primary: #000` rules and you will have to define them manually as usual.
```html
<!-- @MARK fg:var(--primary) -->
<div class="fg:var(--primary)">…</div>
```
It will be compiled to:
```css
.fg\:var\(--primary\) {
    color: var(--primary);
}
```