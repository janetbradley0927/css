## Overview [sr-only]
Traditionally, we define components like `.btn` or `.card` by writing CSS rules. In Master CSS, we use `config.components` to abstract and make them more flexible.
<Code lang="js" name="master.css.js">{require('./tests/apply-styles/master.css.js?raw').default}</Code>
An abstract style consists of one or more syntaxes, you can provide a class name for this set of classes and reuse it anywhere.

(click) Try making the viewport width smaller
<ResizeZone width="100%" originX="center" showRuler>
    <IFrame src="/examples/responsive-button" height={138} />
</ResizeZone>
You can even conditionally apply abstract styles via at-rules:
<Code lang="html">{require('./tests/apply-styles/template.html?raw').default}</Code>
<details>
    <summary>Generated CSS</summary>
    <div>
        <Code lang="css" beautify>{require('./tests/apply-styles/generated.css?raw').default}</Code>
    </div>
</details>

---

## Basic usage
### Add a style
Create an abstract style using Master CSS syntaxes.
<Overview />

### Add a style with states
Create an abstract style with [state selectors](/guide/state-selectors) and [applying conditionally](/guide/applying-conditionally).
<Code lang="js" name="master.css.js">{require('./tests/add-a-style-with-states/master.css.js?raw').default}</Code>
(click) Try clicking the button to see the outline effect
<Demo>
    <button className="center-content inline-flex bg:invert fg:invert font:14 font:medium h:10x px:4x r:2x outline:2|invert:focus outline-offset:2:focus">Submit</button>
</Demo>
<Code lang="html">{require('./tests/add-a-style-with-states/template.html?raw').default}</Code>
<details>
    <summary>Generated CSS</summary>
    <div>
        <Code lang="css" beautify>{require('./tests/add-a-style-with-states/generated.css?raw').default}</Code>
    </div>
</details>

### Add styles in a nested structure
Create and manage a set of abstract styles in a nested structure. Rather than repeating the same style names over and over again, you can write one style inside another. Master CSS will automatically combine the outer style’s name with the inner style’s.
<Code lang="js" name="master.css.js">{require('./tests/add-styles-in-a-nested-structure/master.css.js?raw').default}</Code>
Apply the components:
<Code lang="html">{require('./tests/add-styles-in-a-nested-structure/template.html?raw').default}</Code>
<details>
    <summary>Generated CSS</summary>
    <div>
        <Code lang="css" beautify>{require('./tests/add-styles-in-a-nested-structure/generated.css?raw').default}</Code>
    </div>
</details>
The empty string `''` represents an outer style, much like Sass's `&`.

### Extend an existing style
Create a new abstract style by extending an existing style and adding additional syntax.
<Code lang="js" name="master.css.js">{require('./tests/extend-an-existing-style/master.css.js?raw').default}</Code>
You can see that `b` inherits the text lime color of `a`:
<Demo $py={0}>
    <DemoPanel>
        <span className="font:20 fg:lime">a</span>
        <span className="font:20 fg:lime text:underline">b</span>
    </DemoPanel>
</Demo>
<Code lang="html">{require('./tests/extend-an-existing-style/template.html?raw').default}</Code>
<details>
    <summary>Generated CSS</summary>
    <div>
        <Code lang="css" beautify>{require('./tests/extend-an-existing-style/generated.css?raw').default}</Code>
    </div>
</details>

---

## Managing styles
As usual, you can split the styles into multiple files for management. When the project is small in scale, you don't necessarily have to insist on splitting style files.
<ExplorerView>
{[
    { name: 'styles', children: [
        { name: 'button.ts' },
        { name: 'card.ts' }
    ]},
    { name: 'master.css.ts' }
]}
</ExplorerView>

### Create button styles
Let's implement a rich button.
<Code lang="ts" name="styles/button.ts">
    {require('~/site/styles/btn?raw').default}
</Code>
[Extend](/guide/configuration#extends) them uniformly in the __master.css.ts__ entry file.
```js name=master.css.ts
import type { Config } from '@master/css'
import button from './styles/button'

export default {
    extends: [
        button
    ]
} as Config
```

To apply the button sizes.
<Demo className="gap:8x">
    <button className="btn btn-xs yellow touch-yellow">Submit</button>
    <button className="btn btn-sm yellow touch-yellow">Submit</button>
    <button className="btn btn-md yellow touch-yellow">Submit</button>
    <button className="btn btn-lg yellow touch-yellow">Submit</button>
    <button className="btn btn-xl yellow touch-yellow">Submit</button>
</Demo>
```html
<!-- @MARK btn-xs -->
<button class="btn btn-xs …">Submit</button>
<!-- @MARK btn-sm -->
<button class="btn btn-sm …">Submit</button>
<!-- @MARK btn-md -->
<button class="btn btn-md …">Submit</button>
<!-- @MARK btn-lg -->
<button class="btn btn-lg …">Submit</button>
<!-- @MARK btn-xl -->
<button class="btn btn-xl …">Submit</button>
```
To apply the button sizes that are finely tuned for rounded styles.
<Demo className="gap:8x">
    <button className="btn btn-rounded-xs yellow touch-yellow">Submit</button>
    <button className="btn btn-rounded-sm yellow touch-yellow">Submit</button>
    <button className="btn btn-rounded-md yellow touch-yellow">Submit</button>
    <button className="btn btn-rounded-lg yellow touch-yellow">Submit</button>
    <button className="btn btn-rounded-xl yellow touch-yellow">Submit</button>
</Demo>
```html
<!-- @MARK btn-rounded-xs -->
<button class="btn btn-rounded-xs …">Submit</button>
<!-- @MARK btn-rounded-sm -->
<button class="btn btn-rounded-sm …">Submit</button>
<!-- @MARK btn-rounded-md -->
<button class="btn btn-rounded-md …">Submit</button>
<!-- @MARK btn-rounded-lg -->
<button class="btn btn-rounded-lg …">Submit</button>
<!-- @MARK btn-rounded-xl -->
<button class="btn btn-rounded-xl …">Submit</button>
```
To design a scalable style, you should ensure the single responsibility of class composition; otherwise, you may end up using a lot of `!important` to override rules or the `@preset` layer to lower default styles, ultimately leading to chaotic styles.

### Create common variables and styles
We define [variables and modes](/guide/variables-and-modes) to create tokens supporting light/dark modes in advance. This not only simplifies template markup but also reduces CSS rule output.
<Code lang="ts" name="master.css.ts">
    {require('~/site/styles/base?raw').default}
</Code>
- Variables
    - `yellow-ring` is an outline color that complements a yellow background.
    - `touch-yellow` is a background color on hover.
    - `text-yellow-contrast` is a contrasting color fine-tuned against a yellow background.
- Components
    - `.yellow` sets a background, foreground and outline style for a yellow theme.
    - `.yellow-touch` sets a background, foreground and outline style for a yellow theme interaction.

<Demo className="gap:8x">
    <button className="btn btn-md yellow touch-yellow">Submit</button>
</Demo>
```html
<!-- @MARK yellow touch-yellow -->
<button class="btn btn-md yellow touch-yellow">Submit</button>
```